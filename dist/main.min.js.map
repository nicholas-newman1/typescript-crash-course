{"version":3,"sources":["src/ts/1-basics.ts","src/ts/2-object-types.ts","src/ts/3-array-types.ts","src/ts/4-tuples.ts"],"names":["num1","num2","printResult","add","n1","n2","Error","console","log","data","person","name","age","person2","hobbies","hobbiesUC","map","hobby","toUpperCase","data2","coordinate","push"],"mappings":"AAgBA,IAAIA,KAAO,EACPC,KAAO,EACPC,aAAc,EAIlB,SAASC,IAAIC,EAAYC,GAKvB,GAAkB,iBAAPD,GAAiC,iBAAPC,EACnC,MAAM,IAAIC,MAAM,qCAGlB,OAAOF,EAAKC,EAGVH,aAAaK,QAAQC,IAAIL,IAAIH,KAAMC,OChCvC,ICUIQ,KDVEC,OAAS,CACbC,KAAM,OACNC,IAAK,IAIDC,QAGF,CACFF,KAAM,OACNC,IAAK,ICZDE,QAAU,CAAC,SAAU,WAIrBC,UAAYD,QAAQE,IAAI,SAACC,GAE7B,OAAOA,EAAMC,gBAWfC,MAAQ,CAAC,EAAG,KAAK,GCbjBC,WAAa,CAAC,EAAG,GAGjBA,WAAWC,KAAK","file":"main.min.js","sourcesContent":["/* Core Types\r\n\r\n- number (integers and floats/doubles)\r\n- string\r\n- boolean (true/false only, no truthy/falsy values)\r\n- object (more specific types of object are possible)\r\n- Array (element types can be flexible or strict)\r\n\r\n*/\r\n\r\n// define a type with ': type' after variable name\r\n\r\n/* No need to define type when declaring and assigning value to a variable.\r\nTypeScript will infer the type based on the value being assigned. If you don't\r\nassign a value immediately after declaration, then it is a good idea to specify\r\nits type */\r\nlet num1 = 1; // number\r\nlet num2 = 2; // number\r\nlet printResult = false; // boolean\r\n\r\n/* The following function will not accept any other type than number as a\r\nparameter. Any attempt to pass another type will display an error. */\r\nfunction add(n1: number, n2: number) {\r\n  /* The following if statement could be used to check for types in vanilla JS,\r\n  but this will throw an error at runtime instead of during development. It is\r\n  better to catch the error earlier. Also, vanilla JS cannot check for all the\r\n  types that TypeScript can check for */\r\n  if (typeof n1 !== 'number' && typeof n2 !== 'number') {\r\n    throw new Error('Parameters must be of type number');\r\n  }\r\n\r\n  return n1 + n2;\r\n}\r\n\r\nif (printResult) console.log(add(num1, num2));\r\n","/* TypeScript infers the object type { name: string; age: number; }. Cannot add\r\nadditional properties because they don't exist on the object type */\r\nconst person = {\r\n  name: 'Nick',\r\n  age: 20,\r\n};\r\n\r\n/* Explicit declaration of object type. This is an anti-pattern. */\r\nconst person2: {\r\n  name: string;\r\n  age: number;\r\n} = {\r\n  name: 'John',\r\n  age: 30,\r\n};\r\n","/* TypeScript infers hobbies is of type string[], an array of strings. */\r\nconst hobbies = ['Sports', 'Cookies'];\r\n\r\n/* The inference of type string[] on hobbies allows us to perform actions\r\non it with certainty of its type. */\r\nconst hobbiesUC = hobbies.map((hobby) => {\r\n  // hobby.forEach(x => console.log(x)) // ERROR: hobby is of type string\r\n  return hobby.toUpperCase();\r\n});\r\n\r\n/* If we are not assigning a value immediately, it is a good idea to specify\r\nthe type */\r\nlet data: string[];\r\n\r\n/* If we want to allow for any type in an array we can use the type any[].\r\nNote: any should only be used when necessay, as it takes away the benefits\r\nof specifying types */\r\nlet data2: any[];\r\ndata2 = [1, '2', true];\r\n","/* Tuples are an array with fixed length of 2. Without explicity specifying the type, TypeScript will assume it is of type Array*/\r\nlet coordinate: [number, number];\r\n\r\n// coordinate = [] // ERROR\r\n// coordinate = [1, 2, 3] // ERROR\r\ncoordinate = [1, 1];\r\n\r\n/* Note the push method is an unexpected exception */\r\ncoordinate.push(3);\r\n"]}